use crate::util;
use crate::ast::{Expr, BinOp, UnOp};

grammar;

match {
    "," => COMMA,
    ":" => COLON,
    ";" => SEMICOLON,
    "(" => LPAREN,
    ")" => RPAREN,
    "[" => LBRACK,
    "]" => RBRACK,
    "{" => LBRACE,
    "}" => RBRACE,
    "." => DOT,
    "+" => ADD,
    "-" => SUB,
    "*" => MUL,
    "/" => DIV,
    "=" => EQ,
    "<>" => NE,
    "<" => LT,
    "<=" => LE,
    ">" => GT,
    ">=" => GE,
    "&" => AND,
    "|" => OR,
    "~" => NOT,
    ":=" => ASSIGN,
    "array" => ARRAY,
    "if" => IF,
    "then" => THEN,
    "else" => ELSE,
    "while" => WHILE,
    "for" => FOR,
    "to" => TO,
    "do" => DO,
    "let" => LET,
    "in" => IN,
    "end" => END,
    "of" => OF,
    "break" => BREAK,
    "nil" => NIL,
    "function" => FUNC,
    "var" => VAR,
    "type" => TYPE,
    r"[A-Za-z][A-Za-z0-9_]*" => IDENT,
    r"[1-9][0-9]*|0" => INTEGER,
    r#""([:print:]|\\[nt"\\]|\\[0-9]{3}|\\\s+\\)*""# => STRING,
    r"\s+" => { },
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },
}

pub Expr: Box<Expr> = {
    #[precedence(level="1")]
    <l:@L> <literal:INTEGER> <r:@R> => Box::new(Expr::Integer { loc: (l, r), value: util::parse_integer_literal(literal) }),
    #[precedence(level="1")]
    <l:@L> <literal:STRING> <r:@R> => Box::new(Expr::String { loc: (l, r), value: util::parse_string_literal(literal) }),
    #[precedence(level="1")]
    <l:@L> NIL <r:@R> => Box::new(Expr::Nil { loc: (l, r) }),
    #[precedence(level="1")]
    <l:@L> BREAK <r:@R> => Box::new(Expr::Break { loc: (l, r) }),
    #[precedence(level="1")]
    <l:@L> <name:IDENT> <r:@R> => Box::new(Expr::Ident { loc: (l, r), name: String::from(name) }),
    #[precedence(level="1")]
    <l:@L> <record:Expr> DOT <attr:IDENT> <r:@R> => Box::new( Expr::Attr { loc: (l, r), record, attr: String::from(attr) } ),
    #[precedence(level="1")]
    <l:@L> <array:Expr> LBRACK <index:Expr> RBRACK <r:@R> => Box::new( Expr::Index { loc: (l, r), array, index } ),
    #[precedence(level="1")]
    <l:@L> <typ:IDENT> LBRACE <init:Expr> SEMICOLON <size:Expr> RBRACE <r:@R> => Box::new(Expr::Array { loc: (l, r), typ: String::from(typ), size, init }),
    #[precedence(level="1")]
    <l:@L> <typ:IDENT> LBRACE <elems:RecordElems> RBRACE <r:@R> => Box::new(Expr::Record { loc: (l, r), typ: String::from(typ), elems }),
    #[precedence(level="1")]
    SeqExpr,
    #[precedence(level="2")]
    <l:@L> ADD <expr:Expr> <r:@R> => Box::new(Expr::UnOp { loc: (l, r), op: UnOp::Pos, expr }),
    #[precedence(level="2")]
    <l:@L> SUB <expr:Expr> <r:@R> => Box::new(Expr::UnOp { loc: (l, r), op: UnOp::Neg, expr }),
    #[precedence(level="2")]
    <l:@L> NOT <expr:Expr> <r:@R> => Box::new(Expr::UnOp { loc: (l, r), op: UnOp::Not, expr }),
    #[precedence(level="3")]
    #[assoc(side="left")]
    <l:@L> <lhs:Expr> MUL <rhs:Expr> <r:@R> => Box::new(Expr::BinOp { loc: (l, r), lhs, op: BinOp::Mul, rhs }),
    #[precedence(level="3")]
    #[assoc(side="left")]
    <l:@L> <lhs:Expr> DIV <rhs:Expr> <r:@R> => Box::new(Expr::BinOp { loc: (l, r), lhs, op: BinOp::Div, rhs }),
    #[precedence(level="4")]
    #[assoc(side="left")]
    <l:@L> <lhs:Expr> ADD <rhs:Expr> <r:@R> => Box::new(Expr::BinOp { loc: (l, r), lhs, op: BinOp::Add, rhs }),
    #[precedence(level="4")]
    #[assoc(side="left")]
    <l:@L> <lhs:Expr> SUB <rhs:Expr> <r:@R> => Box::new(Expr::BinOp { loc: (l, r), lhs, op: BinOp::Sub, rhs }),
    #[precedence(level="5")]
    #[assoc(side="none")]
    <l:@L> <lhs:Expr> EQ <rhs:Expr> <r:@R> => Box::new(Expr::BinOp { loc: (l, r), lhs, op: BinOp::Eq, rhs }),
    #[precedence(level="5")]
    #[assoc(side="none")]
    <l:@L> <lhs:Expr> NE <rhs:Expr> <r:@R> => Box::new(Expr::BinOp { loc: (l, r), lhs, op: BinOp::NE, rhs }),
    #[precedence(level="5")]
    #[assoc(side="none")]
    <l:@L> <lhs:Expr> LT <rhs:Expr> <r:@R> => Box::new(Expr::BinOp { loc: (l, r), lhs, op: BinOp::LT, rhs }),
    #[precedence(level="5")]
    #[assoc(side="none")]
    <l:@L> <lhs:Expr> LE <rhs:Expr> <r:@R> => Box::new(Expr::BinOp { loc: (l, r), lhs, op: BinOp::LE, rhs }),
    #[precedence(level="5")]
    #[assoc(side="none")]
    <l:@L> <lhs:Expr> GT <rhs:Expr> <r:@R> => Box::new(Expr::BinOp { loc: (l, r), lhs, op: BinOp::GT, rhs }),
    #[precedence(level="5")]
    #[assoc(side="none")]
    <l:@L> <lhs:Expr> GE <rhs:Expr> <r:@R> => Box::new(Expr::BinOp { loc: (l, r), lhs, op: BinOp::GE, rhs }),
    #[precedence(level="6")]
    #[assoc(side="left")]
    <l:@L> <lhs:Expr> AND <rhs:Expr> <r:@R> => Box::new(Expr::BinOp { loc: (l, r), lhs, op: BinOp::And, rhs }),
    #[precedence(level="6")]
    #[assoc(side="left")]
    <l:@L> <lhs:Expr> OR <rhs:Expr> <r:@R> => Box::new(Expr::BinOp { loc: (l, r), lhs, op: BinOp::Or, rhs }),
    #[precedence(level="7")]
    <l:@L> IF <test:Expr> THEN <body:SeqExpr> <r:@R> => Box::new(Expr::If { loc: (l, r), test, body, orelse: Box::new(Expr::Empty { loc: (r, r) }) } ),
    #[precedence(level="7")]
    <l:@L> IF <test:Expr> THEN <body:SeqExpr> ELSE <orelse:SeqExpr> <r:@R> => Box::new(Expr::If { loc: (l, r), test, body, orelse } ),
    #[precedence(level="7")]
    <l:@L> WHILE <test:Expr> DO <body:SeqExpr> <r:@R> => Box::new(Expr::While { loc: (l, r), test, body }),
    #[precedence(level="7")]
    <l:@L> FOR <var:IDENT> ASSIGN <low:Expr> TO <high:Expr> DO <body:SeqExpr> <r:@R> => Box::new(Expr::For { loc: (l, r), var: String::from(var), low, high, body }),
    #[precedence(level="8")]
    #[assoc(side="none")]
    <l:@L> <var:Expr> ASSIGN <expr:Expr> <r:@R> => Box::new(Expr::Assign { loc: (l, r), var, expr }),
};

SeqExpr: Box<Expr> = <l:@L> LPAREN <mut exprs:ExprList> RPAREN <r:@R> => { let expr = Box::new(exprs.pop().unwrap()); Box::new(Expr::Seq { loc: (l, r), exprs, expr }) };

ExprList: Vec<Expr> = {
    <l:@L> () <r:@R> => vec![Expr::Empty { loc: (l, r) }],
    <expr:Expr> => vec![*expr],
    <expr:Expr> SEMICOLON <mut exprs:ExprList> => { let mut result = vec![*expr]; result.append(&mut exprs); result }
};

RecordElem: (String, Expr) = <attr:IDENT> COLON <expr:Expr> => (String::from(attr), *expr);

RecordElems: Vec<(String, Expr)> = {
    () => vec![],
    <elem:RecordElem> => vec![elem],
    <elem:RecordElem> COMMA <mut elems:RecordElems> => { elems.insert(0, elem); elems }
};
